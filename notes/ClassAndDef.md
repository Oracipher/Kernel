### 1. `api.py` —— 这里的核心词是“代理与安全”

这个文件的作用是**隔离**。它站在“插件”和“内核”之间，防止插件胡作非为。

#### **类：`Omni`**
*   **作用**：它是**内核功能的代理人（Facade/Proxy）**。插件只能看到 `Omni`，看不到 `MicroKernel` 的真身。它的核心任务是提供有限的、安全的操作接口。
*   **导师注解**：名字起得不错（Omni 有“全能”之意），但在设计模式中，这被称为**沙箱模式（Sandbox）**的一部分。

#### **函数/方法列表**：

1.  **`__init__(self, kernel, plugin_name)`**
    *   **作用**：初始化代理。保存了内核的引用（`_kernel`）和当前插件的名字。
    *   **关键点**：定义了 `_protected_keys`（受保护的键），这是为了防止插件修改核心配置（如 `admin` 账号）。

2.  **`log(self, message)`**
    *   **作用**：打印日志，但会自动带上 `[插件名]` 的前缀。
    *   **关键点**：方便调试，一眼就能看出是哪个插件在说话。

3.  **`gazer(self, event_name, callback)`**
    *   **作用**：注册事件监听。
    *   **逻辑**：它不自己处理，而是转手交给内核（`self._kernel.monitor`）。但在转交前做了一层检查（`callable`），防止传入不能执行的东西导致内核崩溃。

4.  **`on(self, event_name, callback)`**
    *   **作用**：`gazer` 的别名。
    *   **关键点**：这是为了照顾不同开发者的习惯（类似于 JavaScript 中的 `.on()`），属于“语法糖”。

5.  **`emit(self, event_name, **kwargs)`**
    *   **作用**：触发一个事件，通知其他插件。
    *   **逻辑**：同样是转手交给内核去广播。

6.  **`_check_permission(self, key)`**
    *   **作用**：内部安保人员。检查插件想要修改的数据 `key` 是否在受保护名单里。
    *   **关键点**：这是一个私有辅助方法，不仅拒绝访问，还会记录“安全警报”。

7.  **`get_data(self, key, default=None)`**
    *   **作用**：获取全局数据。
    *   **核心逻辑**：**深拷贝（Deep Copy）**。这是最关键的一点！它给插件的不是数据的“真身”，而是“复印件”。插件随便改这个复印件，都不会影响内核里的原件。

8.  **`set_data(self, key, value)`**
    *   **作用**：修改/设置全局数据。
    *   **逻辑**：先调用 `_check_permission` 查岗，通过了才允许修改内核数据。

9.  **`append_data(self, key, value)`**
    *   **作用**：专门用于向列表类型的数据追加内容（例如日志列表、消息队列）。
    *   **逻辑**：包含了类型检查（确保目标是 `list`）和权限检查。

---

### 2. `interface.py` —— 这里的核心词是“契约与规范”

这个文件定义了规则。如果不遵守这个规则，内核就不带你玩。

#### **类：`Proot`**
*   **作用**：**抽象基类（Abstract Base Class）**。它定义了所有插件必须长什么样。
*   **导师注解**：`Proot` 继承自 `ABC`，配合 `@abstractmethod`，强制子类必须实现指定方法，否则子类无法实例化（会报错）。这保证了内核调用 `plugin.start()` 时绝对不会出错。

#### **函数/方法列表**：

1.  **`__init__(self, api)`**
    *   **作用**：接收内核发下来的“通行证”（即 `api.py` 中的 `Omni` 实例）。

2.  **`start(self) -> None`** (抽象方法)
    *   **作用**：插件的入口。
    *   **规定**：所有插件必须在这里写启动逻辑（比如注册监听器、打印欢迎语）。

3.  **`stop(self) -> None`** (抽象方法)
    *   **作用**：插件的出口。
    *   **规定**：所有插件必须在这里写清理逻辑（比如关闭文件、取消监听），防止内存泄漏。

---

### 3. `kernel.py` —— 这里的核心词是“调度与生命周期”

这是系统的大脑，负责最脏最累的活：加载代码、管理内存、分发消息。

#### **类：`MicroKernel`**
*   **作用**：微内核本体。管理插件生命周期和全局上下文。

#### **函数/方法列表**：

**A. 基础与事件系统**

1.  **`__init__(self)`**
    *   **作用**：初始化“世界”。创建插件目录，定义全局上下文 `context`，初始化用于存储插件和模块的字典。

2.  **`monitor(self, event_name, callback_func)`**
    *   **作用**：内核级的事件注册。把函数存入 `_events` 字典。

3.  **`emit(self, event_name, **kwargs)`**
    *   **作用**：内核级的事件广播。
    *   **关键点**：遍历列表执行回调。这里加了 `try...except`，确保**一个插件报错不会导致整个内核崩溃**（容错隔离）。

**B. 加载机制 (Loader Mechanism) - 这里的代码最有技术含量**

4.  **`_bootstrap(self, mod, name)`**
    *   **作用**：**引导启动**。当 Python 文件被读取为模块对象 `mod` 后，这个函数负责：
        1.  实例化 `Omni`（制造代理）。
        2.  实例化插件类 `mod.Plugin`。
        3.  检查是否继承了 `Proot`（验明正身）。
        4.  调用 `start()` 启动。

5.  **`_action_loader(self, filename, name, path)`**
    *   **作用**：**动态加载器**。
    *   **逻辑**：使用 `importlib` 从文件路径读取代码，将其变成 Python 的 module 对象，放入 `sys.modules`，然后交给 `_bootstrap` 启动。这是实现“插件化”的核心技术。

**C. 公共管理接口 (Public Methods)**

6.  **`init_plugins(self)`**
    *   **作用**：**扫描器**。遍历 `plugins` 文件夹，找到所有的 `.py` 文件或包，然后批量加载。

7.  **`load_plugin(self, filename)`**
    *   **作用**：加载单个指定插件。

8.  **`stop_plugin(self, name)`**
    *   **作用**：**卸载插件**。
    *   **逻辑**：
        1.  调用插件的 `stop()` 方法（优雅退出）。
        2.  从 `loaded_plugins` 移除实例。
        3.  从 `sys.modules` 移除模块引用（这对内存回收和重载至关重要）。

9.  **`reload_plugin(self, name)`**
    *   **作用**：**热重载**。
    *   **逻辑**：先 `stop` 再 `load`。这允许你在不关闭程序的情况下更新插件代码，非常适合开发调试。

10. **`list_plugins(self)`**
    *   **作用**：列出当前活着的插件名。
